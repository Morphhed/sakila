// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sakila-city.sql

package db

import (
	"context"
	"database/sql"
)

const createCity = `-- name: CreateCity :execresult
INSERT INTO city (city, country_id) VALUES (?, ?)
`

type CreateCityParams struct {
	City      string `db:"city" json:"city"`
	CountryID uint16 `db:"country_id" json:"country_id"`
}

func (q *Queries) CreateCity(ctx context.Context, arg CreateCityParams) (sql.Result, error) {
	return q.exec(ctx, q.createCityStmt, createCity, arg.City, arg.CountryID)
}

const deleteCity = `-- name: DeleteCity :exec
DELETE FROM city WHERE city_id = ?
`

func (q *Queries) DeleteCity(ctx context.Context, cityID uint16) error {
	_, err := q.exec(ctx, q.deleteCityStmt, deleteCity, cityID)
	return err
}

const getCity = `-- name: GetCity :one
SELECT city_id, city, country_id, last_update FROM city WHERE city_id = ? LIMIT 1
`

func (q *Queries) GetCity(ctx context.Context, cityID uint16) (City, error) {
	row := q.queryRow(ctx, q.getCityStmt, getCity, cityID)
	var i City
	err := row.Scan(
		&i.CityID,
		&i.City,
		&i.CountryID,
		&i.LastUpdate,
	)
	return i, err
}

const listCities = `-- name: ListCities :many
SELECT city_id, city, country_id, last_update FROM city ORDER BY city_id
`

func (q *Queries) ListCities(ctx context.Context) ([]City, error) {
	rows, err := q.query(ctx, q.listCitiesStmt, listCities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []City{}
	for rows.Next() {
		var i City
		if err := rows.Scan(
			&i.CityID,
			&i.City,
			&i.CountryID,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCitiesByCountry = `-- name: ListCitiesByCountry :many
SELECT city_id, city, country_id, last_update FROM city WHERE country_id = ? ORDER BY city
`

func (q *Queries) ListCitiesByCountry(ctx context.Context, countryID uint16) ([]City, error) {
	rows, err := q.query(ctx, q.listCitiesByCountryStmt, listCitiesByCountry, countryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []City{}
	for rows.Next() {
		var i City
		if err := rows.Scan(
			&i.CityID,
			&i.City,
			&i.CountryID,
			&i.LastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCity = `-- name: UpdateCity :exec
UPDATE city SET city = ?, country_id = ? WHERE city_id = ?
`

type UpdateCityParams struct {
	City      string `db:"city" json:"city"`
	CountryID uint16 `db:"country_id" json:"country_id"`
	CityID    uint16 `db:"city_id" json:"city_id"`
}

func (q *Queries) UpdateCity(ctx context.Context, arg UpdateCityParams) error {
	_, err := q.exec(ctx, q.updateCityStmt, updateCity, arg.City, arg.CountryID, arg.CityID)
	return err
}
